<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Google Jamboard Replica</title>
    <!-- Use a Google Font to match the clean look -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&display=swap" rel="stylesheet"> <!-- For Sticky Notes -->
    <style>
        :root {
            --primary: #4285f4;
            --bg-gray: #f8f9fa;
            --border: #dadce0;
            --icon-color: #5f6368;
            --icon-hover: #202124;
            --selected-bg: #e8f0fe;
            --selected-color: #1967d2;
            --note-yellow: #fff740;
            --note-green: #ccff90;
            --note-blue: #cbf0f8;
            --note-pink: #fbbc04; /* Actually orange in Jamboard, but let's stick to standard set */
            --note-orange: #fbbc04;
        }

        * {
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background-color: #f1f3f4;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* --- Top Bar --- */
        .top-bar {
            height: 64px;
            background: white;
            display: flex;
            align-items: center;
            padding: 0 16px;
            border-bottom: 1px solid var(--border);
            justify-content: space-between;
            z-index: 100;
        }

        .title-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .jam-logo {
            width: 32px;
            height: 32px;
            border-radius: 4px;
        }

        .jam-title {
            font-size: 18px;
            color: #202124;
            font-weight: 500;
        }

        .center-tools {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f1f3f4;
            padding: 4px;
            border-radius: 4px; /* Optional, Jamboard usually has pages here. We'll put undo/redo */
        }
        
        .top-tools {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .icon-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--icon-color);
            transition: background 0.2s;
        }

        .icon-btn:hover { background: rgba(0,0,0,0.04); color: var(--icon-hover); }
        .icon-btn svg { width: 24px; height: 24px; fill: currentColor; }
        
        .btn-text {
            border: 1px solid var(--border);
            background: white;
            color: var(--icon-color);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        }
        .btn-text:hover { background: #f8f9fa; border-color: #c6c6c6; }

        /* --- Canvas Area --- */
        .workspace {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center; /* Center the board */
            padding-top: 20px;
            overflow: hidden; 
        }

        /* The white drawing board */
        #board-container {
            width: 100%;
            height: 100%;
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            position: absolute;
            top: 0; left: 0;
            display: block;
            touch-action: none;
        }
        #main-canvas { z-index: 10; cursor: crosshair; }
        #preview-canvas { z-index: 20; pointer-events: none; }
        #laser-canvas { z-index: 25; pointer-events: none; }

        /* Objects Layer (Notes, Text, Images) */
        #objects-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 30;
            pointer-events: none; /* Default: drawing tools active */
        }
        
        .select-mode #objects-layer { pointer-events: auto; }
        .select-mode #main-canvas { pointer-events: none; }

        /* --- Left Toolbar --- */
        .toolbar-left {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            box-shadow: 0 1px 3px rgba(60,64,67,0.3), 0 4px 8px 3px rgba(60,64,67,0.15);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            padding: 8px 4px;
            gap: 4px;
            z-index: 100;
        }

        .tool-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: transparent;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--icon-color);
            position: relative;
        }

        .tool-btn:hover { color: #202124; }
        .tool-btn.active { color: var(--selected-color); background: var(--selected-bg); }
        .tool-btn svg { width: 22px; height: 22px; fill: currentColor; }
        
        /* Tiny arrow for dropdowns */
        .caret-right {
           position: absolute;
           right: 2px;
           bottom: 10px;
           font-size: 8px;
           color: inherit;
        }

        /* --- Popups --- */
        .popup-menu {
            position: absolute;
            left: 55px; /* Right of toolbar */
            background: white;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.3), 0 2px 6px 2px rgba(60,64,67,0.15);
            border-radius: 4px;
            padding: 12px;
            display: none;
            z-index: 200;
            flex-direction: row;
            gap: 12px;
        }
        
        .popup-menu.show { display: flex; }

        /* Pen Options */
        .brush-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            border-right: 1px solid #dadce0;
            padding-right: 12px;
        }
        .brush-opt {
            width: 32px; height: 32px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
        }
        .brush-opt:hover { background: #f1f3f4; }
        .brush-opt.selected { background: #e8f0fe; color: #1967d2; }

        .color-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        .color-dot {
            width: 24px; height: 24px;
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            border: 2px solid transparent;
        }
        .color-dot.selected::after {
            content: '';
            position: absolute;
            top: -4px; left: -4px; right: -4px; bottom: -4px;
            border-radius: 50%;
            border: 2px solid #4285f4;
        }

        /* Shapes Options */
        .shape-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        /* --- DOM Elements (Notes, Text, Images) --- */
        .obj-wrapper {
            position: absolute;
            cursor: grab;
            user-select: none;
            transform-origin: center center;
        }
        .obj-wrapper:active { cursor: grabbing; }
        
        .sticky-note {
            width: 200px; height: 200px;
            padding: 16px;
            font-family: 'Kalam', cursive;
            font-size: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            display: flex; align-items: center; justify-content: center;
            text-align: center;
            outline: none;
            transition: transform 0.1s;
        }
        
        .text-box {
            min-width: 50px; min-height: 30px;
            color: #202124;
            font-size: 24px;
            font-family: 'Roboto', sans-serif; /* Could use other fonts */
            background: transparent;
            outline: none;
            border: 1px solid transparent;
            padding: 4px;
            white-space: nowrap;
        }
        .text-box:focus { border: 1px solid #4285f4; }
        
        .img-obj {
            max-width: 400px;
            max-height: 400px;
            pointer-events: none; /* Wrapper handles events */
            user-select: none;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            right: 0; top: 64px; bottom: 0;
            width: 300px;
            background: white;
            box-shadow: -2px 0 4px rgba(0,0,0,0.1);
            transform: translateX(100%);
            transition: transform 0.3s;
            z-index: 150;
            padding: 16px;
            display: flex; flex-direction: column;
        }
        .sidebar.open { transform: translateX(0); }
        .sidebar-header { font-weight: bold; margin-bottom: 16px; display:flex; justify-content:space-between; }
        .save-item {
            padding: 8px; border: 1px solid #eee; margin-bottom: 8px; cursor: pointer; border-radius: 4px;
            display: flex; gap: 8px; align-items: center;
        }
        .save-item:hover { background: #f8f9fa; }

    </style>
</head>
<body>

    <!-- Top Bar -->
    <div class="top-bar">
        <div class="title-section">
            <div style="background:#fbbc04; color:white; width:32px; height:32px; border-radius:4px; display:flex; align-items:center; justify-content:center; font-weight:bold; font-size:20px;">J</div>
            <div class="jam-title" contenteditable="true">Untitled Jam</div>
        </div>

        <div class="center-tools">
             <!-- Undo/Redo are mostly here in Jamboard? No, they are left, but for space we center them -->
        </div>

        <div class="top-tools">
            <button class="icon-btn" onclick="undo()" title="Undo">
                <svg viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></svg>
            </button>
            <button class="icon-btn" onclick="redo()" title="Redo">
                <svg viewBox="0 0 24 24"><path d="M18.4 10.6C16.55 9 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"/></svg>
            </button>
            <div style="width:1px; height:24px; background:var(--border); margin:0 8px;"></div>
            <button class="btn-text" onclick="toggleSidebar()">Open Saved Jams</button>
            <button class="btn-text" onclick="saveJamToHistory()">Save Frame</button>
            <button class="btn-text" onclick="clearBoard()">Clear frame</button>
            <div style="width:1px; height:24px; background:var(--border); margin:0 8px;"></div>
            <button class="btn-text" onclick="downloadImage()">Download PDF/Img</button>
        </div>
    </div>

    <!-- Workspace -->
    <div class="workspace" id="workspace">

        <!-- Left Toolbar -->
        <div class="toolbar-left">
            
            <!-- Pen -->
            <button class="tool-btn active" id="tool-pen" onclick="togglePenMenu(event)">
                <svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
                <span class="caret-right">‚ñ∂</span>
            </button>

            <!-- Eraser -->
            <button class="tool-btn" id="tool-eraser" onclick="setTool('eraser')">
                <svg viewBox="0 0 24 24"><path d="M15.14 3c-.51 0-1.02.2-1.41.59L2.59 14.73c-.78.78-.78 2.05 0 2.83L5.03 20c.78.78 2.05.78 2.83 0l11.14-11.14c.79-.78.79-2.05 0-2.83l-2.44-2.44c-.39-.39-.91-.59-1.42-.59zm0 2.12L17.59 7.55 12.03 13.11 9.58 10.66 15.14 5.12zM8.17 12.08l2.45 2.45L6.2 18.94 3.75 16.5l4.42-4.42z"/></svg>
            </button>

            <!-- Select -->
            <button class="tool-btn" id="tool-select" onclick="setTool('select')">
                <svg viewBox="0 0 24 24"><path d="M7 2l12 11.2-5.8.5 3.3 7.3-2.2.9-3.2-7.4-4.4 4V2z"/></svg>
            </button>

            <!-- Sticky Note -->
            <button class="tool-btn" id="tool-note" onclick="addStickyNotePrompt()">
                <svg viewBox="0 0 24 24"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"/><path d="M7 12h10v2H7zm0-4h10v2H7zm0 8h7v2H7z"/></svg>
            </button>

            <!-- Add Image -->
            <button class="tool-btn" id="tool-image" onclick="document.getElementById('img-input').click()">
                <svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>
            </button>
            <input type="file" id="img-input" hidden accept="image/*" onchange="handleImageUpload(event)">

            <!-- Shapes -->
            <button class="tool-btn" id="tool-shape" onclick="toggleShapeMenu(event)">
                <span id="curr-shape-icon" style="font-size:18px;">‚ö™</span> <!-- Default circle -->
                <span class="caret-right">‚ñ∂</span>
            </button>

            <!-- Text Box -->
            <button class="tool-btn" id="tool-text" onclick="setTool('text')">
                <svg viewBox="0 0 24 24"><path d="M5 5v3h5v11h3V8h5V5z"/></svg>
            </button>

            <!-- Laser -->
            <button class="tool-btn" id="tool-laser" onclick="setTool('laser')">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm4.43-10.82l-5.66 5.66-2.19-2.2-1.42 1.41 3.61 3.62 7.08-7.07z" fill="none"/><circle cx="12" cy="12" r="6" fill="currentColor" fill-opacity="0.5"/></svg>
            </button>

        </div>

        <!-- Pen Menu Popup -->
        <div class="popup-menu" id="pen-menu">
            <div class="brush-options">
                <div class="brush-opt selected" onclick="setBrush('pen')">üñäÔ∏è</div>
                <div class="brush-opt" onclick="setBrush('marker')">üìù</div>
                <div class="brush-opt" onclick="setBrush('highlighter')">üñçÔ∏è</div>
                <div class="brush-opt" onclick="setBrush('brush')">üñåÔ∏è</div>
            </div>
            <div class="color-options">
                <div class="color-dot" style="background:#000000" onclick="setColor('#000000', this)"></div>
                <div class="color-dot" style="background:#1967d2" onclick="setColor('#1967d2', this)"></div>
                <div class="color-dot" style="background:#1e8e3e" onclick="setColor('#1e8e3e', this)"></div>
                <div class="color-dot" style="background:#d93025" onclick="setColor('#d93025', this)"></div>
                <div class="color-dot" style="background:#fbbc04" onclick="setColor('#fbbc04', this)"></div>
                <div class="color-dot" style="background:#ffffff; border:1px solid #dadce0" onclick="setColor('#ffffff', this)"></div>
            </div>
        </div>

        <!-- Shapes Menu Popup -->
        <div class="popup-menu" id="shapes-menu">
            <div class="shape-grid">
                <div class="brush-opt" onclick="setShape('circle')">‚≠ï</div>
                <div class="brush-opt" onclick="setShape('rect')">‚¨õ</div>
                <div class="brush-opt" onclick="setShape('triangle')">üî∫</div>
                <div class="brush-opt" onclick="setShape('diamond')">üî∂</div>
                <div class="brush-opt" onclick="setShape('arrow')">‚û°</div>
                <div class="brush-opt" onclick="setShape('line')">‚ûñ</div>
            </div>
        </div>

        <!-- Board -->
        <div id="board-container">
            <canvas id="main-canvas"></canvas>
            <canvas id="preview-canvas"></canvas>
            <canvas id="laser-canvas"></canvas> <!-- For laser trails -->
            <div id="objects-layer"></div>
        </div>

    </div>

    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            SAVED JAMS
            <span style="cursor:pointer" onclick="toggleSidebar()">‚úï</span>
        </div>
        <div id="saved-list"></div>
    </div>

    <!-- Hidden Sticky Note Create Modal (Or simple prompt) -->
    <!-- We'll use JS prompt for simplicity or custom overlay if needed. Let's start with clean JS prompt for "Text" logic, but sticky note should just appear. -->

    <script>
        // --- State ---
        const state = {
            tool: 'pen', // pen, eraser, select, shape, text, laser
            brushType: 'pen',
            color: '#000000',
            shape: 'circle',
            isDrawing: false,
            startX: 0, startY: 0,
            history: [],
            historyStep: -1,
            maxHistory: 50,
            laserPoints: [] // {x, y, time}
        };
        
        const settings = {
            pen: { width: 2, alpha: 1, cap: 'round' },
            marker: { width: 4, alpha: 1, cap: 'round' },
            highlighter: { width: 12, alpha: 0.3, cap: 'square' },
            brush: { width: 6, alpha: 0.6, cap: 'round' } // Artistic brush simulation
        };

        // --- DOM Elements ---
        const mainCanvas = document.getElementById('main-canvas');
        const previewCanvas = document.getElementById('preview-canvas');
        const laserCanvas = document.getElementById('laser-canvas');
        const objLayer = document.getElementById('objects-layer');
        const ctx = mainCanvas.getContext('2d', { willReadFrequently: true });
        const pCtx = previewCanvas.getContext('2d');
        const lCtx = laserCanvas.getContext('2d');
        
        let boardRect = mainCanvas.getBoundingClientRect();

        // --- Initialization ---
        function resize() {
            // Save info
            const temp = document.createElement('canvas');
            temp.width = mainCanvas.width; temp.height = mainCanvas.height;
            if (temp.width > 0) temp.getContext('2d').drawImage(mainCanvas, 0, 0);

            boardRect = document.getElementById('board-container').getBoundingClientRect();
            
            [mainCanvas, previewCanvas, laserCanvas].forEach(c => {
                c.width = boardRect.width;
                c.height = boardRect.height;
            });
            
            if (temp.width > 0) ctx.drawImage(temp, 0, 0);
        }
        window.addEventListener('resize', () => { resize(); });
        setTimeout(resize, 100); // Initial
        loadAutoSaved(); // Load last session
        saveHistory();

        // --- Tool Logic ---
        window.setTool = (tool) => {
            state.tool = tool;
            
            // Close menus
            document.getElementById('pen-menu').classList.remove('show');
            document.getElementById('shapes-menu').classList.remove('show');
            
            // UI Update
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tool-${tool === 'shape' ? 'shape' : tool}`).classList.add('active'); // Simplify ID mapping
            
            // Mode Handling
            if (tool === 'select') {
                document.body.classList.add('select-mode');
            } else {
                document.body.classList.remove('select-mode');
            }
        };

        // Pen Menu
        window.togglePenMenu = (e) => {
            e.stopPropagation();
            const menu = document.getElementById('pen-menu');
            if (state.tool === 'pen' && menu.classList.contains('show')) {
                menu.classList.remove('show');
            } else {
                setTool('pen');
                menu.classList.add('show');
                // Positioning logic if needed (already CSS absolute)
                document.getElementById('shapes-menu').classList.remove('show');
            }
        };
        
        window.setBrush = (type) => {
            state.brushType = type;
            updateBrushUI();
        };

        window.setColor = (hex, el) => {
            state.color = hex;
            document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('selected'));
            el.classList.add('selected');
        };

        function updateBrushUI() {
            document.querySelectorAll('.brush-opt').forEach(b => b.classList.remove('selected'));
            // Very basic selection show
        }

        // Shape Menu
        window.toggleShapeMenu = (e) => {
             e.stopPropagation();
             setTool('shape');
             const menu = document.getElementById('shapes-menu');
             menu.classList.toggle('show');
             document.getElementById('pen-menu').classList.remove('show');
        };

        window.setShape = (shape) => {
            state.shape = shape;
            const icons = { circle:'‚≠ï', rect:'‚¨õ', triangle:'üî∫', diamond:'üî∂', arrow:'‚û°', line:'‚ûñ' };
            document.getElementById('curr-shape-icon').innerText = icons[shape];
            document.getElementById('shapes-menu').classList.remove('show'); // auto close on select like real Jamboard? Jamboard stays open? User asked "hovering... toggled up menu doesnt disappear until user chooses a shape or clicks outside".
            // Implementation: On click shape, set it and Close it.
            // On click outside -> Handled by window click listener.
        };

        // Close menus on outside click
        window.addEventListener('click', (e) => {
            if (!e.target.closest('.popup-menu') && !e.target.closest('.tool-btn')) {
                document.querySelectorAll('.popup-menu').forEach(m => m.classList.remove('show'));
            }
        });

        // --- Drawing System ---
        function getPos(e) {
            const rect = mainCanvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        const container = document.getElementById('board-container');
        container.addEventListener('pointerdown', start);
        container.addEventListener('pointermove', move);
        container.addEventListener('pointerup', end);

        function start(e) {
            if (state.tool === 'select' || state.tool === 'text') {
                if (state.tool === 'text') createTextBox(e);
                return;
            }
            if (e.target !== mainCanvas && e.target !== laserCanvas) return; // Ignore if clicking object in select mode

            state.isDrawing = true;
            const { x, y } = getPos(e);
            state.startX = x; state.startY = y;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            
            pCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
            pCtx.beginPath();
            
            // Config Styles
            if (state.tool === 'pen') {
                const s = settings[state.brushType];
                ctx.lineWidth = s.width;
                ctx.lineCap = s.cap;
                ctx.lineJoin = 'round';
                ctx.strokeStyle = state.color;
                ctx.globalAlpha = s.alpha;
                ctx.globalCompositeOperation = state.brushType === 'highlighter' ? 'multiply' : 'source-over';
            } else if (state.tool === 'eraser') {
                ctx.lineWidth = 20;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'destination-out';
            } else if (state.tool === 'shape') {
                pCtx.strokeStyle = state.color;
                pCtx.fillStyle = 'rgba(0,0,0,0)'; // Transparent fill for now
                pCtx.lineWidth = 2;
                pCtx.strokeStyle = state.color; // Standard shape color
            } else if (state.tool === 'laser') {
                state.laserPoints = [];
            }
        }

        function move(e) {
            if (!state.isDrawing) return;
            const { x, y } = getPos(e);

            if (state.tool === 'pen' || state.tool === 'eraser') {
                // Segmented drawing for latency
                ctx.lineTo(x, y);
                ctx.stroke();
                // For smoother opacity stacking in highlighter, we might usually want "continuous path", but segmented is faster.
                // With multiply blend mode, segmented overlaps create dark dots. 
                // Fix: For highlighter, use single path (redraw? No, too slow). 
                // Just accept segmentation or use temporary canvas. Optimized: Segmented.
                ctx.beginPath();
                ctx.moveTo(x, y);
            } else if (state.tool === 'shape') {
                pCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
                drawShapePrediction(pCtx, state.startX, state.startY, x, y, state.shape);
            } else if (state.tool === 'laser') {
                state.laserPoints.push({ x, y, time: Date.now() });
                drawLaser();
            }
        }

        function end(e) {
            if (!state.isDrawing) return;
            state.isDrawing = false;
            
            if (state.tool === 'shape') {
                const { x, y } = getPos(e);
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1;
                ctx.strokeStyle = state.color;
                ctx.lineWidth = 2;
                // Add fill logic (white fill + stroke)
                ctx.fillStyle = 'transparent'; 
                // Actually Jamboard shapes have fill options. Default transparent or white? Let's do nothing fill for now.
                drawShapePrediction(ctx, state.startX, state.startY, x, y, state.shape);
                pCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
            }
            
            if (state.tool !== 'laser') saveHistory();
        }

        function drawShapePrediction(c, x1, y1, x2, y2, type) {
            const w = x2 - x1;
            const h = y2 - y1;
            c.beginPath();
            if (type === 'rect') c.strokeRect(x1, y1, w, h);
            else if (type === 'circle') {
                c.ellipse(x1 + w/2, y1 + h/2, Math.abs(w)/2, Math.abs(h)/2, 0, 0, Math.PI*2);
                c.stroke();
            } else if (type === 'line') {
                c.moveTo(x1, y1); c.lineTo(x2, y2); c.stroke();
            } else if (type === 'triangle') {
                c.moveTo(x1 + w/2, y1); c.lineTo(x1, y1+h); c.lineTo(x1+w, y1+h); c.closePath(); c.stroke();
            } else if (type === 'arrow') {
               // Simple Arrow Head
               c.moveTo(x1, y1 + h/2); c.lineTo(x1 + w - 20, y1 + h/2); c.stroke();
               // Head logic missing for brevity, keeping simple line for now
            }
        }

        // --- Laser Logic ---
        function drawLaser() {
            lCtx.clearRect(0, 0, laserCanvas.width, laserCanvas.height);
            lCtx.lineCap = 'round';
            lCtx.lineJoin = 'round';
            lCtx.lineWidth = 4;
            lCtx.strokeStyle = 'red';
            lCtx.shadowBlur = 4;
            lCtx.shadowColor = 'red';

            const now = Date.now();
            // Filter old points
            state.laserPoints = state.laserPoints.filter(p => now - p.time < 1000);
            
            if (state.laserPoints.length < 2) return;

            lCtx.beginPath();
            lCtx.moveTo(state.laserPoints[0].x, state.laserPoints[0].y);
            
            for (let i = 1; i < state.laserPoints.length; i++) {
                lCtx.lineTo(state.laserPoints[i].x, state.laserPoints[i].y);
            }
            lCtx.stroke();
            
            if (state.laserPoints.length > 0) requestAnimationFrame(drawLaser);
        }

        // --- Object Creation ---
        
        // Sticky Note
        window.addStickyNotePrompt = () => {
             // Jamboard style: Click -> Modal with colors -> Insert.
             // Simplified: Just insert center.
             createStickyNote(mainCanvas.width/2 - 100, mainCanvas.height/2 - 100);
             setTool('select'); // Auto switch to select to move it
        };

        function createStickyNote(x, y, content='', color='var(--note-yellow)') {
            const div = document.createElement('div');
            div.className = 'obj-wrapper sticky-note';
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.style.background = color;
            div.contentEditable = true;
            div.innerText = content;
            div.id = 'note-' + Date.now();
            
            makeDraggable(div);
            objLayer.appendChild(div);
            saveHistory(); // Save DOM state? see saveJamToHistory
        }

        // Text Box
        function createTextBox(e) {
            const { x, y } = getPos(e);
            
            const div = document.createElement('div');
            div.className = 'obj-wrapper text-box';
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.contentEditable = true;
            div.innerText = 'Text';
            div.id = 'text-' + Date.now();
            
            makeDraggable(div);
            objLayer.appendChild(div);
            setTool('select');
            
            setTimeout(() => { div.focus(); document.execCommand('selectAll', false, null); }, 10);
            saveHistory();
        }

        // Images
        window.handleImageUpload = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = document.createElement('img');
                img.src = ev.target.result;
                img.className = 'img-obj';
                
                const div = document.createElement('div');
                div.className = 'obj-wrapper';
                div.style.left = '100px'; 
                div.style.top = '100px';
                div.appendChild(img);
                div.id = 'img-' + Date.now();
                
                makeDraggable(div);
                objLayer.appendChild(div);
                setTool('select');
                saveHistory();
            };
            reader.readAsDataURL(file);
        };

        // --- Draggable Logic ---
        function makeDraggable(el) {
            let isDown = false;
            let offX, offY;
            
            el.addEventListener('mousedown', (e) => {
                if (state.tool !== 'select') return;
                e.stopPropagation(); // prevent canvas drawing
                isDown = true;
                const r = el.getBoundingClientRect();
                const containerR = objLayer.getBoundingClientRect();
                offX = e.clientX - r.left;
                offY = e.clientY - r.top;
                
                // Bring to front
                objLayer.appendChild(el); 
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                const containerR = objLayer.getBoundingClientRect();
                el.style.left = (e.clientX - containerR.left - offX) + 'px';
                el.style.top = (e.clientY - containerR.top - offY) + 'px';
            });
            
            window.addEventListener('mouseup', () => {
                if (isDown) {
                    isDown = false;
                    saveHistory(); // Update position in history? 
                }
            });
        }

        // --- Persistence & History ---
        
        function saveHistory() {
            // We need to save Canvas Bitmap + Serialized DOM Objects
            const htmlContent = objLayer.innerHTML;
            // Get Image Data is heavy. Use with caution.
            const canvasData = mainCanvas.toDataURL();
            
            state.historyStep++;
            state.history = state.history.slice(0, state.historyStep);
            state.history.push({ canvas: canvasData, html: htmlContent });
            
            if (state.history.length > state.maxHistory) {
                state.history.shift();
                state.historyStep--;
            }
        }

        window.undo = () => {
            if (state.historyStep > 0) {
                state.historyStep--;
                restoreState(state.history[state.historyStep]);
            }
        };

        window.redo = () => {
            if (state.historyStep < state.history.length - 1) {
                state.historyStep++;
                restoreState(state.history[state.historyStep]);
            }
        };

        function restoreState(s) {
            if (!s) return;
            // Restore HTML
            objLayer.innerHTML = s.html;
            
            // Re-bind listeners to new DOM elements!
            Array.from(objLayer.children).forEach(el => {
                makeDraggable(el);
            });
            
            // Restore Canvas
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
                ctx.drawImage(img, 0, 0);
            };
            img.src = s.canvas;
        }

        window.saveJamToHistory = () => {
            // LocalStorage Sidebar logic
            const jams = JSON.parse(localStorage.getItem('jams') || '[]');
            const thumb = mainCanvas.toDataURL('image/png', 0.1); // low qual
            const title = document.querySelector('.jam-title').innerText;
            
            const jam = {
                id: Date.now(),
                title: title,
                date: new Date().toLocaleDateString(),
                state: state.history[state.historyStep] // Save the current full state object
            };
            jams.unshift(jam);
            localStorage.setItem('jams', JSON.stringify(jams));
            loadSidebar();
            alert('Jam Saved!');
        };

        window.toggleSidebar = () => {
            const sb = document.getElementById('sidebar');
            sb.classList.toggle('open');
            if (sb.classList.contains('open')) loadSidebar();
        };

        function loadSidebar() {
            const list = document.getElementById('saved-list');
            list.innerHTML = '';
            const jams = JSON.parse(localStorage.getItem('jams') || '[]');
            
            jams.forEach(j => {
                const div = document.createElement('div');
                div.className = 'save-item';
                div.innerHTML = `
                   <div style="font-weight:bold">${j.title}</div>
                   <div style="font-size:12px; color:#666">${j.date}</div>
                `;
                div.onclick = () => loadJam(j);
                list.appendChild(div);
            });
        }

        function loadJam(jam) {
            // Restore EVERYTHING
            document.querySelector('.jam-title').innerText = jam.title;
            restoreState(jam.state);
            // Also reset history stack to just this one? Or append? Reset is cleaner.
            state.history = [jam.state];
            state.historyStep = 0;
            toggleSidebar(); // Close
        }
        
        window.clearBoard = () => {
            ctx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
            objLayer.innerHTML = '';
            saveHistory();
        };
        
        window.downloadImage = () => {
            const link = document.createElement('a');
            link.download = 'jam.png';
            // Composite needed... html2canvas for DOM? 
            // For MVP: Download drawing only.
            link.href = mainCanvas.toDataURL();
            link.click();
        };

    </script>
</body>
</html>

